// Usage:
// bun run scripts/generate-ai-tools-types.ts
//
// This script fetches AI tool schemas from the document-cognition service
// and generates TS types for use in the chat block and service package.

import { mkdir, readFile } from "node:fs/promises";
import * as path from "node:path";
import { join } from "node:path";
import { $ } from "bun";
import { resolveRefs } from "json-refs";
import { compile } from "json-schema-to-typescript";
import { jsonSchemaToZod } from "json-schema-to-zod";
import { z } from "zod";
import { documentCognitionBase, serviceUrl } from "./services";

const serviceDir = path.resolve(
	import.meta.dirname,
	documentCognitionBase.output,
);
const outputDir = join(serviceDir, "generated", "tools");
const schemasFile = join(outputDir, "schemas.ts");
const typesFile = join(outputDir, "types.ts");
const toolFile = join(outputDir, "tool.ts");

await $`rm ${schemasFile} ${toolFile} ${typesFile}|| true`;

const warning = `/* Generated by scripts/generate-ai-tools.ts
  * *DO NOT EDIT MANUALLY*
  *
*/`;

await mkdir(outputDir, { recursive: true });

const AiToolsResponseSchema = z.object({
	schemas: z.array(
		z.object({
			name: z.string(),
			inputSchema: z.any(),
			outputSchema: z.any(),
		}),
	),
});

type AiToolsResponse = z.infer<typeof AiToolsResponseSchema>["schemas"];

async function fetchAIToolsSchemas(): Promise<AiToolsResponse> {
	const path =
		"../../rust/cloud-storage/document_cognition_service/schemas/tools.json";
	try {
		const data = await readFile(path, "utf-8");
		const parsed = AiToolsResponseSchema.parse(JSON.parse(data));
		console.log(`Successfully loaded ${parsed.schemas.length} AI tool schemas`);
		return parsed.schemas;
	} catch (error) {
		console.error("Failed to load AI tools schemas:", error);
		throw error;
	}
}

async function generateSchemasFile(tools: AiToolsResponse) {
	// Generate all schemas
	const content: Array<string> = [];
	for (const tool of tools) {
		// jsonSchemaToZod with name option generates a proper export
		const { resolved: inputSchema } = await resolveRefs(tool.inputSchema);
		const inputCode = jsonSchemaToZod(inputSchema, {
			module: "esm",
			name: `${tool.name}InputSchema`,
			withoutDescribes: true,
			noImport: true,
		});

		const { resolved: outputSchema } = await resolveRefs(tool.outputSchema);
		const outputCode = jsonSchemaToZod(outputSchema, {
			module: "esm",
			name: `${tool.name}OutputSchema`,
			withoutDescribes: true,
			noImport: true,
		});

		content.push(`${inputCode}\n\n${outputCode}`);
	}

	const contents = `${warning}
import { z } from 'zod';

${content.join("\n\n")}
`;

	await Bun.write(schemasFile, contents);
}

async function generateToolTypesFile(tools: AiToolsResponse) {
	// Generate all schemas
	const content: Array<string> = [];
	for (const tool of tools) {
		const inputCode = await compile(
			tool.inputSchema,
			`${tool.name}InputSchema`,
			{
				// override top level name for export
				customName: (schema) => {
					if (schema.title) {
						const newName = `${tool.name}Input`;
						console.log(`Renamed ${schema.title} to ${newName}`);
						return newName;
					}
				},
				additionalProperties: false,
				style: {
					singleQuote: true,
				},
			},
		);

		const outputCode = await compile(
			tool.outputSchema,
			`${tool.name}OutputSchema`,
			{
				// override top level name for export
				customName: (schema) => {
					if (schema.title) {
						const newName = `${tool.name}Output`;
						console.log(`Renamed ${schema.title} to ${newName}`);
						return newName;
					}
					return undefined;
				},
				additionalProperties: false,
				style: {
					singleQuote: true,
				},
			},
		);

		content.push(`${inputCode}\n\n${outputCode}`);
	}

	const contents = `${warning}
${content.join("\n\n")}
`;

	await Bun.write(typesFile, contents);
}

async function generateToolsFile(tools: AiToolsResponse) {
	const contents = `${warning}

import { err, type MaybeResult, ok } from 'core/util/maybeResult';
import type { Component } from 'solid-js';
import * as schemas from './schemas';
import type * as types from './types';

type ToolParserMap = {
${tools
	.map(
		(tool) =>
			`${tool.name}: { call: types.${tool.name}Input, response: types.${tool.name}Output }`,
	)
	.join("\n")}
};

const toolParserMap = {
${tools
	.map(
		(tool) =>
			`${tool.name}: { call: schemas.${tool.name}InputSchema, response: schemas.${tool.name}OutputSchema }`,
	)
	.join(",\n")}
};

export type ToolName = keyof ToolParserMap;

type NamedRawTool = {
  id: string;
  name: string;
  json: unknown;
};

type ToolDataMap = {
${tools
	.map(
		(tool) =>
			`${tool.name}: { call: types.${tool.name}Input, response: types.${tool.name}Output }`,
	)
	.join(";\n")};
};

export type NamedTool<
  TName extends ToolName = ToolName,
  TDirection extends 'call' | 'response' = 'call' | 'response',
> = {
  id: string;
  name: TName;
  data: ToolDataMap[TName][TDirection];
};

export type ToolContext<TTool extends NamedTool = NamedTool> = {
  tool: TTool;
  chat_id: string;
  message_id: string;
  part_index: number;
  isComplete: boolean;
};

export interface ToolHandler<T extends NamedTool, RenderContext> {
  handle?: (context: ToolContext<T>) => void | Promise<void>;
  render?: Component<ToolContext<T> & RenderContext>;
}

function deserializeTool<T extends NamedTool>(
  tool: NamedRawTool,
  direction: 'call' | 'response'
): MaybeResult<'parse_error' | 'not_found', T> {
  if (!(tool.name in toolParserMap)) {
    return err('not_found', \`tool name not found \${tool.name}\`);
  }
  const parser = toolParserMap[tool.name as ToolName];
  const maybeToolCall = parser[direction].safeParse(tool.json);
  if (maybeToolCall.success) {
    return ok({
      id: tool.id,
      name: tool.name as ToolName,
      data: maybeToolCall.data,
    } as T);
  }
  return err('parse_error', 'tool parsing failed');
}

export function deserializeToolCall(
  tool: NamedRawTool
): MaybeResult<'parse_error' | 'not_found', NamedTool<ToolName, 'call'>> {
  return deserializeTool(tool, 'call');
}

export function deserializeToolResponse(
  tool: NamedRawTool
): MaybeResult<'parse_error' | 'not_found', NamedTool<ToolName, 'response'>> {
  return deserializeTool(tool, 'response');
}

export type ToolHandlerMap<RenderContext>= {
  [K in ToolName]: {
    call: ToolHandler<NamedTool<K, 'call'>,RenderContext>;
    response: ToolHandler<NamedTool<K, 'response'>, RenderContext>;
  };
};
`;
	await Bun.write(toolFile, contents);
}

// Fetch AI tools schemas
const tools = await fetchAIToolsSchemas();
// Sort tools by name to maintain consistent order
tools.sort((a, b) => a.name.localeCompare(b.name));
// write types
await generateSchemasFile(tools);
await generateToolsFile(tools);
await generateToolTypesFile(tools);
await $`bunx biome format --write --no-errors-on-unmatched ${toolFile} ${schemasFile} ${typesFile}`;

console.log(
	`Generated AI tools types at: ${serviceDir}/generated/tools/tools.ts`,
);

console.log("âœ… AI tools types generation completed successfully");
