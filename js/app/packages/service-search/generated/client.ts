/**
 * Generated by orval v7.13.0 ðŸº
 * Do not edit manually.
 * search_service
 * OpenAPI spec version: 0.1.0
 */
import type {
  ChannelSearchParams,
  ChannelSearchRequest,
  ChannelSearchResponse,
  ChatSearchParams,
  ChatSearchRequest,
  ChatSearchResponse,
  DocumentSearchParams,
  DocumentSearchRequest,
  DocumentSearchResponse,
  EmailSearchParams,
  EmailSearchRequest,
  EmailSearchResponse,
  EmptyResponse,
  ErrorResponse,
  ProjectSearchParams,
  ProjectSearchRequest,
  SearchResponse,
  SimpleChannelSearchParams,
  SimpleChannelSearchResponse,
  SimpleChatSearchParams,
  SimpleChatSearchResponse,
  SimpleDocumentSearchParams,
  SimpleDocumentSearchResponse,
  SimpleEmailSearchParams,
  SimpleEmailSearchResponse,
  SimpleProjectSearchParams,
  SimpleProjectSearchResponse,
  SimpleUnifiedSearchBaseResponse,
  SimpleUnifiedSearchParams,
  UnifiedSearchParams,
  UnifiedSearchRequest,
  UnifiedSearchResponse
} from './models';

/**
 * @summary Health check
 */
export type healthHandlerResponse200 = {
  data: EmptyResponse
  status: 200
}
    
export type healthHandlerResponseSuccess = (healthHandlerResponse200) & {
  headers: Headers;
};
;

export type healthHandlerResponse = (healthHandlerResponseSuccess)

export const getHealthHandlerUrl = () => {


  

  return `/health`
}

export const healthHandler = async ( options?: RequestInit): Promise<healthHandlerResponse> => {
  
  const res = await fetch(getHealthHandlerUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: healthHandlerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as healthHandlerResponse
}



/**
 * @summary Perform a search through all items
 */
export type unifiedSearchResponse200 = {
  data: UnifiedSearchResponse
  status: 200
}

export type unifiedSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type unifiedSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type unifiedSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type unifiedSearchResponseSuccess = (unifiedSearchResponse200) & {
  headers: Headers;
};
export type unifiedSearchResponseError = (unifiedSearchResponse400 | unifiedSearchResponse401 | unifiedSearchResponse500) & {
  headers: Headers;
};

export type unifiedSearchResponse = (unifiedSearchResponseSuccess | unifiedSearchResponseError)

export const getUnifiedSearchUrl = (params: UnifiedSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search?${stringifiedParams}` : `/search`
}

export const unifiedSearch = async (unifiedSearchRequest: UnifiedSearchRequest,
    params: UnifiedSearchParams, options?: RequestInit): Promise<unifiedSearchResponse> => {
  
  const res = await fetch(getUnifiedSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      unifiedSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: unifiedSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as unifiedSearchResponse
}



/**
 * @summary Perform a search through your emails
 */
export type channelSearchResponse200 = {
  data: ChannelSearchResponse
  status: 200
}

export type channelSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type channelSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type channelSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type channelSearchResponseSuccess = (channelSearchResponse200) & {
  headers: Headers;
};
export type channelSearchResponseError = (channelSearchResponse400 | channelSearchResponse401 | channelSearchResponse500) & {
  headers: Headers;
};

export type channelSearchResponse = (channelSearchResponseSuccess | channelSearchResponseError)

export const getChannelSearchUrl = (params: ChannelSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/channel?${stringifiedParams}` : `/search/channel`
}

export const channelSearch = async (channelSearchRequest: ChannelSearchRequest,
    params: ChannelSearchParams, options?: RequestInit): Promise<channelSearchResponse> => {
  
  const res = await fetch(getChannelSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      channelSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: channelSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as channelSearchResponse
}



/**
 * @summary Perform a search through your chats
 */
export type chatSearchResponse200 = {
  data: ChatSearchResponse
  status: 200
}

export type chatSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type chatSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type chatSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type chatSearchResponseSuccess = (chatSearchResponse200) & {
  headers: Headers;
};
export type chatSearchResponseError = (chatSearchResponse400 | chatSearchResponse401 | chatSearchResponse500) & {
  headers: Headers;
};

export type chatSearchResponse = (chatSearchResponseSuccess | chatSearchResponseError)

export const getChatSearchUrl = (params: ChatSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/chat?${stringifiedParams}` : `/search/chat`
}

export const chatSearch = async (chatSearchRequest: ChatSearchRequest,
    params: ChatSearchParams, options?: RequestInit): Promise<chatSearchResponse> => {
  
  const res = await fetch(getChatSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      chatSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: chatSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as chatSearchResponse
}



/**
 * @summary Perform a search through your documents
 */
export type documentSearchResponse200 = {
  data: DocumentSearchResponse
  status: 200
}

export type documentSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type documentSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type documentSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type documentSearchResponseSuccess = (documentSearchResponse200) & {
  headers: Headers;
};
export type documentSearchResponseError = (documentSearchResponse400 | documentSearchResponse401 | documentSearchResponse500) & {
  headers: Headers;
};

export type documentSearchResponse = (documentSearchResponseSuccess | documentSearchResponseError)

export const getDocumentSearchUrl = (params: DocumentSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/document?${stringifiedParams}` : `/search/document`
}

export const documentSearch = async (documentSearchRequest: DocumentSearchRequest,
    params: DocumentSearchParams, options?: RequestInit): Promise<documentSearchResponse> => {
  
  const res = await fetch(getDocumentSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      documentSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: documentSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as documentSearchResponse
}



/**
 * @summary Perform a search through your emails
 */
export type emailSearchResponse200 = {
  data: EmailSearchResponse
  status: 200
}

export type emailSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type emailSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type emailSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type emailSearchResponseSuccess = (emailSearchResponse200) & {
  headers: Headers;
};
export type emailSearchResponseError = (emailSearchResponse400 | emailSearchResponse401 | emailSearchResponse500) & {
  headers: Headers;
};

export type emailSearchResponse = (emailSearchResponseSuccess | emailSearchResponseError)

export const getEmailSearchUrl = (params: EmailSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/email?${stringifiedParams}` : `/search/email`
}

export const emailSearch = async (emailSearchRequest: EmailSearchRequest,
    params: EmailSearchParams, options?: RequestInit): Promise<emailSearchResponse> => {
  
  const res = await fetch(getEmailSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      emailSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: emailSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as emailSearchResponse
}



/**
 * @summary Perform a search through your projects
 */
export type projectSearchResponse200 = {
  data: SearchResponse
  status: 200
}

export type projectSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type projectSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type projectSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type projectSearchResponseSuccess = (projectSearchResponse200) & {
  headers: Headers;
};
export type projectSearchResponseError = (projectSearchResponse400 | projectSearchResponse401 | projectSearchResponse500) & {
  headers: Headers;
};

export type projectSearchResponse = (projectSearchResponseSuccess | projectSearchResponseError)

export const getProjectSearchUrl = (params?: ProjectSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/project?${stringifiedParams}` : `/search/project`
}

export const projectSearch = async (projectSearchRequest: ProjectSearchRequest,
    params?: ProjectSearchParams, options?: RequestInit): Promise<projectSearchResponse> => {
  
  const res = await fetch(getProjectSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: projectSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as projectSearchResponse
}



/**
 * @summary Perform a search through all items.
This is a simple search where we do not group your results by entity id.
 */
export type simpleUnifiedSearchResponse200 = {
  data: SimpleUnifiedSearchBaseResponse
  status: 200
}

export type simpleUnifiedSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type simpleUnifiedSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type simpleUnifiedSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type simpleUnifiedSearchResponseSuccess = (simpleUnifiedSearchResponse200) & {
  headers: Headers;
};
export type simpleUnifiedSearchResponseError = (simpleUnifiedSearchResponse400 | simpleUnifiedSearchResponse401 | simpleUnifiedSearchResponse500) & {
  headers: Headers;
};

export type simpleUnifiedSearchResponse = (simpleUnifiedSearchResponseSuccess | simpleUnifiedSearchResponseError)

export const getSimpleUnifiedSearchUrl = (params: SimpleUnifiedSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/simple?${stringifiedParams}` : `/search/simple`
}

export const simpleUnifiedSearch = async (unifiedSearchRequest: UnifiedSearchRequest,
    params: SimpleUnifiedSearchParams, options?: RequestInit): Promise<simpleUnifiedSearchResponse> => {
  
  const res = await fetch(getSimpleUnifiedSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      unifiedSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: simpleUnifiedSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as simpleUnifiedSearchResponse
}



/**
 * @summary Perform a search through your channels
This is a simple search where we do not group your results by channel id.
 */
export type simpleChannelSearchResponse200 = {
  data: SimpleChannelSearchResponse
  status: 200
}

export type simpleChannelSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type simpleChannelSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type simpleChannelSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type simpleChannelSearchResponseSuccess = (simpleChannelSearchResponse200) & {
  headers: Headers;
};
export type simpleChannelSearchResponseError = (simpleChannelSearchResponse400 | simpleChannelSearchResponse401 | simpleChannelSearchResponse500) & {
  headers: Headers;
};

export type simpleChannelSearchResponse = (simpleChannelSearchResponseSuccess | simpleChannelSearchResponseError)

export const getSimpleChannelSearchUrl = (params: SimpleChannelSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/simple/channel?${stringifiedParams}` : `/search/simple/channel`
}

export const simpleChannelSearch = async (channelSearchRequest: ChannelSearchRequest,
    params: SimpleChannelSearchParams, options?: RequestInit): Promise<simpleChannelSearchResponse> => {
  
  const res = await fetch(getSimpleChannelSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      channelSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: simpleChannelSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as simpleChannelSearchResponse
}



/**
 * @summary Perform a search through your chats
This is a simple search where we do not group your results by chat id.
 */
export type simpleChatSearchResponse200 = {
  data: SimpleChatSearchResponse
  status: 200
}

export type simpleChatSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type simpleChatSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type simpleChatSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type simpleChatSearchResponseSuccess = (simpleChatSearchResponse200) & {
  headers: Headers;
};
export type simpleChatSearchResponseError = (simpleChatSearchResponse400 | simpleChatSearchResponse401 | simpleChatSearchResponse500) & {
  headers: Headers;
};

export type simpleChatSearchResponse = (simpleChatSearchResponseSuccess | simpleChatSearchResponseError)

export const getSimpleChatSearchUrl = (params: SimpleChatSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/simple/chat?${stringifiedParams}` : `/search/simple/chat`
}

export const simpleChatSearch = async (chatSearchRequest: ChatSearchRequest,
    params: SimpleChatSearchParams, options?: RequestInit): Promise<simpleChatSearchResponse> => {
  
  const res = await fetch(getSimpleChatSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      chatSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: simpleChatSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as simpleChatSearchResponse
}



/**
 * @summary Perform a search through your documents
This is a simple search where we do not group yor results by document id.
 */
export type simpleDocumentSearchResponse200 = {
  data: SimpleDocumentSearchResponse
  status: 200
}

export type simpleDocumentSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type simpleDocumentSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type simpleDocumentSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type simpleDocumentSearchResponseSuccess = (simpleDocumentSearchResponse200) & {
  headers: Headers;
};
export type simpleDocumentSearchResponseError = (simpleDocumentSearchResponse400 | simpleDocumentSearchResponse401 | simpleDocumentSearchResponse500) & {
  headers: Headers;
};

export type simpleDocumentSearchResponse = (simpleDocumentSearchResponseSuccess | simpleDocumentSearchResponseError)

export const getSimpleDocumentSearchUrl = (params: SimpleDocumentSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/simple/document?${stringifiedParams}` : `/search/simple/document`
}

export const simpleDocumentSearch = async (documentSearchRequest: DocumentSearchRequest,
    params: SimpleDocumentSearchParams, options?: RequestInit): Promise<simpleDocumentSearchResponse> => {
  
  const res = await fetch(getSimpleDocumentSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      documentSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: simpleDocumentSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as simpleDocumentSearchResponse
}



/**
 * @summary Perform a search through your emails
This is a simple search where we do not group your results by thread id.
 */
export type simpleEmailSearchResponse200 = {
  data: SimpleEmailSearchResponse
  status: 200
}

export type simpleEmailSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type simpleEmailSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type simpleEmailSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type simpleEmailSearchResponseSuccess = (simpleEmailSearchResponse200) & {
  headers: Headers;
};
export type simpleEmailSearchResponseError = (simpleEmailSearchResponse400 | simpleEmailSearchResponse401 | simpleEmailSearchResponse500) & {
  headers: Headers;
};

export type simpleEmailSearchResponse = (simpleEmailSearchResponseSuccess | simpleEmailSearchResponseError)

export const getSimpleEmailSearchUrl = (params: SimpleEmailSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/simple/email?${stringifiedParams}` : `/search/simple/email`
}

export const simpleEmailSearch = async (emailSearchRequest: EmailSearchRequest,
    params: SimpleEmailSearchParams, options?: RequestInit): Promise<simpleEmailSearchResponse> => {
  
  const res = await fetch(getSimpleEmailSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      emailSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: simpleEmailSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as simpleEmailSearchResponse
}



/**
 * @summary Perform a search through your projects
This is a simple search where we do not group your results by project id.
 */
export type simpleProjectSearchResponse200 = {
  data: SimpleProjectSearchResponse
  status: 200
}

export type simpleProjectSearchResponse400 = {
  data: ErrorResponse
  status: 400
}

export type simpleProjectSearchResponse401 = {
  data: ErrorResponse
  status: 401
}

export type simpleProjectSearchResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type simpleProjectSearchResponseSuccess = (simpleProjectSearchResponse200) & {
  headers: Headers;
};
export type simpleProjectSearchResponseError = (simpleProjectSearchResponse400 | simpleProjectSearchResponse401 | simpleProjectSearchResponse500) & {
  headers: Headers;
};

export type simpleProjectSearchResponse = (simpleProjectSearchResponseSuccess | simpleProjectSearchResponseError)

export const getSimpleProjectSearchUrl = (params?: SimpleProjectSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/search/simple/project?${stringifiedParams}` : `/search/simple/project`
}

export const simpleProjectSearch = async (projectSearchRequest: ProjectSearchRequest,
    params?: SimpleProjectSearchParams, options?: RequestInit): Promise<simpleProjectSearchResponse> => {
  
  const res = await fetch(getSimpleProjectSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectSearchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: simpleProjectSearchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as simpleProjectSearchResponse
}
