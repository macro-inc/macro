import type { SelectionCodec } from '@core/collab/awareness';
import { Cursor } from 'loro-crdt';

/** A cursor for a node in a Loro document */
export type NodeCursor = {
  /** the custom unique ID of the node
   * which is generated by the nodeId plugin
   * NOT the node's key */
  nodeId: string;
  /** the loro representation of the cursor */
  cursor: Cursor;
};

/** Serialized NodeCursor */
type NodeCursorRaw = {
  nodeId: string;
  cursor: Uint8Array;
};

type UserAwareness = {
  userId: string | undefined;
  color: string;
};

export type PeerLexicalAwarenessRaw = {
  anchor: NodeCursorRaw;
  focus: NodeCursorRaw;
  user: UserAwareness;
};

export type PeerLexicalAwareness = {
  anchor: NodeCursor;
  focus: NodeCursor;
  user: UserAwareness;
};

/** Conver a Lexical node cursor to a raw node cursor */
function toRaw(cursor: NodeCursor): NodeCursorRaw {
  return {
    nodeId: cursor.nodeId,
    cursor: cursor.cursor.encode(),
  };
}

/** Conver a raw node cursor to a Lexical node cursor */
function fromRaw(raw: NodeCursorRaw): NodeCursor {
  return {
    nodeId: raw.nodeId,
    cursor: Cursor.decode(raw.cursor),
  };
}

export type LexicalSelectionAwarenessRaw = {
  anchor: NodeCursorRaw;
  focus: NodeCursorRaw;
};

export type LexicalSelectionAwareness = {
  anchor: NodeCursor;
  focus: NodeCursor;
};

export const lexicalSelectionCodec: SelectionCodec<
  LexicalSelectionAwareness,
  LexicalSelectionAwarenessRaw
> = {
  encode: (selection) => {
    return {
      anchor: toRaw(selection.anchor),
      focus: toRaw(selection.focus),
    };
  },
  decode: (serialized) => {
    return {
      anchor: fromRaw(serialized.anchor),
      focus: fromRaw(serialized.focus),
    };
  },
};
