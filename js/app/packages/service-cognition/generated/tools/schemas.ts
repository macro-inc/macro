/* Generated by scripts/generate-ai-tools.ts
  * *DO NOT EDIT MANUALLY*
  *
*/
import { z } from 'zod';

export const ListDocumentsInputSchema = z.object({ "exhaustiveSearch": z.boolean().default(false), "fileTypes": z.union([z.array(z.string()), z.null()]), "minAccessLevel": z.union([z.literal("view"), z.literal("comment"), z.literal("edit"), z.literal("owner"), z.literal(null)]), "pageOffset": z.number().int().default(0), "pageSize": z.number().int().default(50) }).strict()


export const ListDocumentsOutputSchema = z.object({ "results": z.array(z.object({ "access_level": z.enum(["view","comment","edit","owner"]), "created_at": z.string().datetime({ offset: true }), "deleted_at": z.union([z.string().datetime({ offset: true }), z.null()]).optional(), "document_id": z.string(), "document_name": z.string(), "file_type": z.union([z.string(), z.null()]).optional(), "owner": z.string(), "project_id": z.union([z.string(), z.null()]).optional(), "updated_at": z.string().datetime({ offset: true }) })), "resultsReturned": z.number().int().gte(0), "totalResults": z.number().int().gte(0) })


export const ListEmailsInputSchema = z.object({ "cursor": z.union([z.string(), z.null()]).default(null), "limit": z.number().int().default(20), "sortMethod": z.enum(["viewed_at","updated_at","created_at","viewed_updated"]).default("viewed_at"), "view": z.object({ "standardLabel": z.union([z.literal("Inbox"), z.literal("Sent"), z.literal("Drafts"), z.literal("Starred"), z.literal("All"), z.literal("Important"), z.literal("Other"), z.literal(null)]), "userLabel": z.union([z.string(), z.null()]) }).strict().default({"standardLabel":null,"userLabel":null}) }).strict()


export const ListEmailsOutputSchema = z.object({ "previews": z.object({ "items": z.array(z.object({ "attachments": z.array(z.object({ "content_id": z.union([z.string(), z.null()]).optional(), "data_url": z.union([z.string(), z.null()]).optional(), "db_id": z.union([z.string(), z.null()]).optional(), "filename": z.union([z.string(), z.null()]).optional(), "mime_type": z.union([z.string(), z.null()]).optional(), "provider_id": z.union([z.string(), z.null()]).optional(), "size_bytes": z.union([z.number().int(), z.null()]).optional() })), "attachmentsMacro": z.array(z.object({ "db_id": z.union([z.string(), z.null()]).optional(), "item_id": z.string(), "item_type": z.string(), "message_id": z.union([z.string(), z.null()]).optional() })), "createdAt": z.number().int(), "id": z.string(), "inboxVisible": z.boolean(), "isDraft": z.boolean(), "isImportant": z.boolean(), "isRead": z.boolean(), "name": z.union([z.string(), z.null()]).optional(), "ownerId": z.string(), "participants": z.array(z.object({ "email_address": z.union([z.string(), z.null()]).optional(), "id": z.union([z.string(), z.null()]).optional(), "link_id": z.string(), "name": z.union([z.string(), z.null()]).optional(), "original_photo_url": z.union([z.string(), z.null()]).optional(), "sfs_photo_url": z.union([z.string(), z.null()]).optional() })), "providerId": z.union([z.string(), z.null()]).optional(), "senderEmail": z.union([z.string(), z.null()]).optional(), "senderName": z.union([z.string(), z.null()]).optional(), "senderPhotoUrl": z.union([z.string(), z.null()]).optional(), "snippet": z.union([z.string(), z.null()]).optional(), "sortTs": z.number().int(), "updatedAt": z.number().int(), "viewedAt": z.union([z.number().int(), z.null()]).optional() })), "next_cursor": z.union([z.string(), z.null()]).optional() }) })


export const MarkdownRewriteInputSchema = z.object({ "instructions": z.string(), "markdown_file_id": z.string() }).strict()


export const MarkdownRewriteOutputSchema = z.object({ "diffs": z.array(z.object({ "markdown_text": z.string(), "node_key": z.string(), "operation": z.string() }).strict()) }).strict()


export const ReadInputSchema = z.object({ "after": z.union([z.number().int(), z.null()]).default(null), "before": z.union([z.number().int(), z.null()]).default(null), "contentType": z.enum(["document","channel","channel-message","chat-thread","chat-message","email-thread","email-message"]), "ids": z.array(z.string()) }).strict()


export const ReadOutputSchema = z.object({ "content": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "content": z.string(), "document_id": z.string(), "metadata": z.object({ "deleted": z.boolean(), "documentName": z.string(), "fileType": z.union([z.string(), z.null()]).optional(), "owner": z.string(), "projectId": z.union([z.string(), z.null()]).optional() }), "type": z.literal("document") }), z.object({ "channel_id": z.string(), "channel_name": z.union([z.string(), z.null()]).optional(), "transcript": z.string(), "type": z.literal("channel") }), z.object({ "conversation": z.array(z.object({ "chat_id": z.string(), "messages": z.array(z.object({ "attachment_summaries": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "Summary": z.object({ "created_at": z.union([z.string().datetime({ offset: true }), z.null()]).optional(), "document_id": z.string(), "id": z.union([z.string(), z.null()]).optional(), "summary": z.string(), "version_id": z.string() }) }).strict(), z.object({ "NoSummary": z.object({ "document_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "content": z.string(), "date": z.string().datetime({ offset: true }) })), "title": z.string() })), "type": z.literal("chat") }), z.object({ "messages": z.array(z.object({ "bcc": z.array(z.string()), "cc": z.array(z.string()), "content": z.string(), "messageId": z.string(), "recipients": z.array(z.string()), "sender": z.string(), "sentAt": z.union([z.string().datetime({ offset: true }), z.null()]).optional() })), "subject": z.union([z.string(), z.null()]).optional(), "thread_id": z.string(), "type": z.literal("email") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) })


export const UnifiedSearchInputSchema = z.object({ "exhaustiveSearch": z.boolean().default(true), "pageOffset": z.number().int().default(0), "pageSize": z.number().int().default(10), "request": z.object({ "filters": z.union([z.object({ "channel": z.union([z.object({ "channel_ids": z.array(z.string()), "mentions": z.array(z.string()), "org_id": z.union([z.number().int(), z.null()]), "sender_ids": z.array(z.string()), "thread_ids": z.array(z.string()) }).strict(), z.null()]), "chat": z.union([z.object({ "chat_ids": z.array(z.string()), "owners": z.array(z.string()), "project_ids": z.array(z.string()), "role": z.array(z.string()) }).strict(), z.null()]), "document": z.union([z.object({ "document_ids": z.array(z.string()), "file_types": z.array(z.string()), "owners": z.array(z.string()), "project_ids": z.array(z.string()) }).strict(), z.null()]), "email": z.union([z.object({ "bcc": z.array(z.string()), "cc": z.array(z.string()), "recipients": z.array(z.string()), "senders": z.array(z.string()) }).strict(), z.null()]), "project": z.union([z.object({ "owners": z.array(z.string()), "project_ids": z.array(z.string()) }).strict(), z.null()]) }).strict(), z.null()]), "include": z.array(z.enum(["documents","chats","emails","channels","projects"])).default([]), "match_type": z.enum(["exact","partial","regexp"]), "search_on": z.enum(["name","content","name_content"]).default("content"), "terms": z.union([z.array(z.string()), z.null()]) }).strict() }).strict()


export const UnifiedSearchOutputSchema = z.object({ "response": z.object({ "results": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "document_id": z.string(), "document_name": z.string(), "file_type": z.string(), "highlight": z.object({ "content": z.array(z.string()).optional(), "name": z.union([z.string(), z.null()]).optional() }), "node_id": z.string(), "owner_id": z.string(), "raw_content": z.union([z.string(), z.null()]).optional(), "type": z.literal("document"), "updated_at": z.string().datetime({ offset: true }) }), z.object({ "chat_id": z.string(), "chat_message_id": z.string(), "highlight": z.object({ "content": z.array(z.string()).optional(), "name": z.union([z.string(), z.null()]).optional() }), "role": z.string(), "title": z.string(), "type": z.literal("chat"), "updated_at": z.string().datetime({ offset: true }), "user_id": z.string() }), z.object({ "bcc": z.array(z.string()), "cc": z.array(z.string()), "highlight": z.object({ "content": z.array(z.string()).optional(), "name": z.union([z.string(), z.null()]).optional() }), "labels": z.array(z.string()), "link_id": z.string(), "message_id": z.string(), "recipients": z.array(z.string()), "sender": z.string(), "sent_at": z.union([z.string().datetime({ offset: true }), z.null()]).optional(), "subject": z.union([z.string(), z.null()]).optional(), "thread_id": z.string(), "type": z.literal("email"), "updated_at": z.string().datetime({ offset: true }), "user_id": z.string() }), z.object({ "channel_id": z.string(), "channel_name": z.union([z.string(), z.null()]).optional(), "channel_type": z.string(), "created_at": z.string().datetime({ offset: true }), "highlight": z.object({ "content": z.array(z.string()).optional(), "name": z.union([z.string(), z.null()]).optional() }), "mentions": z.array(z.string()), "message_id": z.string(), "org_id": z.union([z.number().int(), z.null()]).optional(), "sender_id": z.string(), "thread_id": z.union([z.string(), z.null()]).optional(), "type": z.literal("channel"), "updated_at": z.string().datetime({ offset: true }) }), z.object({ "created_at": z.string().datetime({ offset: true }), "highlight": z.object({ "content": z.array(z.string()).optional(), "name": z.union([z.string(), z.null()]).optional() }), "project_id": z.string(), "project_name": z.string(), "type": z.literal("project"), "updated_at": z.string().datetime({ offset: true }), "user_id": z.string() })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "resultsReturned": z.number().int().gte(0), "totalResults": z.number().int().gte(0) }), "responseSchema": z.any() })


export const WebSearchInputSchema = z.object({ "query": z.string() }).strict()


export const WebSearchOutputSchema = z.object({ "content": z.string(), "results": z.array(z.object({ "name": z.string(), "url": z.string() })) })

