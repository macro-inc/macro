/* Generated by scripts/generate-ai-tools.ts
  * *DO NOT EDIT MANUALLY*
  *
*/

import { err, type MaybeResult, ok } from 'core/util/maybeResult';
import type { Component } from 'solid-js';
import * as schemas from './schemas';
import type * as types from './types';

type ToolParserMap = {
ListDocuments: { call: types.ListDocumentsInput, response: types.ListDocumentsOutput }
ListEmails: { call: types.ListEmailsInput, response: types.ListEmailsOutput }
MarkdownRewrite: { call: types.MarkdownRewriteInput, response: types.MarkdownRewriteOutput }
Read: { call: types.ReadInput, response: types.ReadOutput }
UnifiedSearch: { call: types.UnifiedSearchInput, response: types.UnifiedSearchOutput }
WebSearch: { call: types.WebSearchInput, response: types.WebSearchOutput }
};

const toolParserMap = {
ListDocuments: { call: schemas.ListDocumentsInputSchema, response: schemas.ListDocumentsOutputSchema },
ListEmails: { call: schemas.ListEmailsInputSchema, response: schemas.ListEmailsOutputSchema },
MarkdownRewrite: { call: schemas.MarkdownRewriteInputSchema, response: schemas.MarkdownRewriteOutputSchema },
Read: { call: schemas.ReadInputSchema, response: schemas.ReadOutputSchema },
UnifiedSearch: { call: schemas.UnifiedSearchInputSchema, response: schemas.UnifiedSearchOutputSchema },
WebSearch: { call: schemas.WebSearchInputSchema, response: schemas.WebSearchOutputSchema }
};

export type ToolName = keyof ToolParserMap;

type NamedRawTool = {
  id: string;
  name: string;
  json: unknown;
};

type ToolDataMap = {
ListDocuments: { call: types.ListDocumentsInput, response: types.ListDocumentsOutput };
ListEmails: { call: types.ListEmailsInput, response: types.ListEmailsOutput };
MarkdownRewrite: { call: types.MarkdownRewriteInput, response: types.MarkdownRewriteOutput };
Read: { call: types.ReadInput, response: types.ReadOutput };
UnifiedSearch: { call: types.UnifiedSearchInput, response: types.UnifiedSearchOutput };
WebSearch: { call: types.WebSearchInput, response: types.WebSearchOutput };
};

export type NamedTool<
  TName extends ToolName = ToolName,
  TDirection extends 'call' | 'response' = 'call' | 'response',
> = {
  id: string;
  name: TName;
  data: ToolDataMap[TName][TDirection];
};

export type ToolContext<TTool extends NamedTool = NamedTool> = {
  tool: TTool;
  chat_id: string;
  message_id: string;
  part_index: number;
  isComplete: boolean;
};

export interface ToolHandler<T extends NamedTool, RenderContext> {
  handle?: (context: ToolContext<T>) => void | Promise<void>;
  render?: Component<ToolContext<T> & RenderContext>;
}

function deserializeTool<T extends NamedTool>(
  tool: NamedRawTool,
  direction: 'call' | 'response'
): MaybeResult<'parse_error' | 'not_found', T> {
  if (!(tool.name in toolParserMap)) {
    return err('not_found', `tool name not found ${tool.name}`);
  }
  const parser = toolParserMap[tool.name as ToolName];
  const maybeToolCall = parser[direction].safeParse(tool.json);
  if (maybeToolCall.success) {
    return ok({
      id: tool.id,
      name: tool.name as ToolName,
      data: maybeToolCall.data,
    } as T);
  }
  return err('parse_error', 'tool parsing failed');
}

export function deserializeToolCall(
  tool: NamedRawTool
): MaybeResult<'parse_error' | 'not_found', NamedTool<ToolName, 'call'>> {
  return deserializeTool(tool, 'call');
}

export function deserializeToolResponse(
  tool: NamedRawTool
): MaybeResult<'parse_error' | 'not_found', NamedTool<ToolName, 'response'>> {
  return deserializeTool(tool, 'response');
}

export type ToolHandlerMap<RenderContext>= {
  [K in ToolName]: {
    call: ToolHandler<NamedTool<K, 'call'>,RenderContext>;
    response: ToolHandler<NamedTool<K, 'response'>, RenderContext>;
  };
};
