/* Generated by scripts/generate-ai-tools.ts
  * *DO NOT EDIT MANUALLY*
  *
*/
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * List documents the user has access to with optional filtering and pagination. Only applies to documents, not emails, AI conversations, chat/slack threads, projects aka folders. This tool returns document metadata including access levels and supports filtering by file type, minimum access level, and pagination. Use this tool to discover and browse documents before using the Read tool to access their content. Prefer using the search tool to search on a specific matching string within the content or the name of the entity.
 */
export interface ListDocumentsInput {
  /**
   * Exhaustive search to get all results. Defaults to false. Set to true when you need all matching documents, ignoring pagination limits.
   */
  exhaustiveSearch: boolean;
  /**
   * Document file types to include. Examples: ['pdf'], ['md', 'txt']. Leave empty to include all document types.
   */
  fileTypes: string[] | null;
  /**
   * Minimum access level required. Defaults to 'view' if not specified.
   */
  minAccessLevel: 'view' | 'comment' | 'edit' | 'owner' | null;
  /**
   * Page offset for pagination. Default is 0. Use higher values to get subsequent pages of results.
   */
  pageOffset: number;
  /**
   * Number of results per page. Max is 100, default is 50. Use smaller values for focused results.
   */
  pageSize: number;
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface ListDocumentsOutput {
  /**
   * The list results (truncated to `results_returned` limit if applicable)
   */
  results: {
    /**
     * The user's access level to this document
     */
    access_level: 'view' | 'comment' | 'edit' | 'owner';
    /**
     * When the document was created
     */
    created_at: string;
    /**
     * When the document was deleted (null if not deleted)
     */
    deleted_at?: string | null;
    /**
     * The document id
     */
    document_id: string;
    /**
     * The document name
     */
    document_name: string;
    /**
     * The file type of the document
     */
    file_type?: string | null;
    /**
     * The owner of the document
     */
    owner: string;
    /**
     * The project id containing the document
     */
    project_id?: string | null;
    /**
     * When the document was last updated
     */
    updated_at: string;
  }[];
  /**
   * The number of results returned
   */
  resultsReturned: number;
  /**
   * Total number of results found
   */
  totalResults: number;
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * List the emails the user has access to. Use this tool to discover and browse emails before using the Read tool to access their content. Prefer using the search tool to search on a specific matching string within the content or the name of the entity.
 */
export interface ListEmailsInput {
  /**
   * A preview response will tell you what the next cursor id is.
   *         If expected emails are not in the current response and it gives you a cursor id, use this field to list the next page of emails. If no cursor id is provided you've reached the end
   */
  cursor: string | null;
  /**
   * limit the max emails returned. This defaults to 20 and has a maximum of 500
   */
  limit: number;
  /**
   * Sort response by one of: viewed_at | updated_at | created_at | viewed_updated. Prefer viewed_at unless the otherwise specified
   */
  sortMethod: 'viewed_at' | 'updated_at' | 'created_at' | 'viewed_updated';
  /**
   * Choose the view to list emails from. One of either standard label or user label must be specified, otherwise defaults to important.
   */
  view: {
    /**
     * Prefer important or all. Leave empty if using a user label
     */
    standardLabel: 'Inbox' | 'Sent' | 'Drafts' | 'Starred' | 'All' | 'Important' | 'Other' | null;
    /**
     * Choose a custom user label to filter by (optional). Standard label will take precedence over user label if both are specified.
     */
    userLabel: string | null;
  };
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface ListEmailsOutput {
  /**
   * the thread, with messages inside
   */
  previews: {
    items: {
      attachments: {
        content_id?: string | null;
        data_url?: string | null;
        db_id?: string | null;
        filename?: string | null;
        mime_type?: string | null;
        provider_id?: string | null;
        size_bytes?: number | null;
      }[];
      attachmentsMacro: {
        db_id?: string | null;
        item_id: string;
        item_type: string;
        message_id?: string | null;
      }[];
      createdAt: number;
      id: string;
      inboxVisible: boolean;
      isDraft: boolean;
      isImportant: boolean;
      isRead: boolean;
      name?: string | null;
      ownerId: string;
      participants: {
        email_address?: string | null;
        id?: string | null;
        link_id: string;
        name?: string | null;
        original_photo_url?: string | null;
        sfs_photo_url?: string | null;
      }[];
      providerId?: string | null;
      senderEmail?: string | null;
      senderName?: string | null;
      senderPhotoUrl?: string | null;
      snippet?: string | null;
      sortTs: number;
      updatedAt: number;
      viewedAt?: number | null;
    }[];
    next_cursor?: string | null;
  };
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Instruct an agent to edit a markdown file identified by an id.
 *     This tool should be used when the user include a markdown file in context and requests a revision or edit to that file
 */
export interface MarkdownRewriteInput {
  /**
   * Instructions for the revision agent to follow to edit the markdown. These instructions will be provided by the user.
   */
  instructions: string;
  /**
   * The markdown file id to target for editing. This file id will be in your context and labeled as a markdown (md) document
   */
  markdown_file_id: string;
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MarkdownRewriteOutput {
  diffs: {
    markdown_text: string;
    node_key: string;
    operation: string;
  }[];
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Read content by ID(s). Supports reading documents, channels, chats, and emails by their respective IDs. Use this tool when you need to retrieve the full content of a specific item(s).
 */
export interface ReadInput {
  /**
   * Number of messages to read after the target message. Only applicable for channel-message content type. Defaults to 0.
   */
  after: number | null;
  /**
   * Number of messages to read before the target message. Only applicable for channel-message content type. Defaults to 0.
   */
  before: number | null;
  /**
   * The type of content to read. Choose based on the type of content you want to retrieve.
   */
  contentType:
    | 'document'
    | 'channel'
    | 'channel-message'
    | 'chat-thread'
    | 'chat-message'
    | 'email-thread'
    | 'email-message';
  /**
   * ID(s) of the content to read. IMPORTANT: Currently only chat-message content type supports MULTIPLE ids! For all other content types provide a single id.
   */
  ids: string[];
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface ReadOutput {
  content:
    | {
        content: string;
        document_id: string;
        metadata: {
          deleted: boolean;
          documentName: string;
          fileType?: string | null;
          owner: string;
          projectId?: string | null;
        };
        type: 'document';
      }
    | {
        channel_id: string;
        channel_name?: string | null;
        transcript: string;
        type: 'channel';
      }
    | {
        conversation: {
          chat_id: string;
          messages: {
            attachment_summaries: (
              | {
                  Summary: {
                    created_at?: string | null;
                    document_id: string;
                    id?: string | null;
                    summary: string;
                    version_id: string;
                  };
                }
              | {
                  NoSummary: {
                    document_id: string;
                  };
                }
            )[];
            content: string;
            date: string;
          }[];
          title: string;
        }[];
        type: 'chat';
      }
    | {
        messages: {
          bcc: string[];
          cc: string[];
          content: string;
          messageId: string;
          recipients: string[];
          sender: string;
          sentAt?: string | null;
        }[];
        subject?: string | null;
        thread_id: string;
        type: 'email';
      };
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Universal search across all content types (documents, emails, AI conversations, chat/slack threads/channels, projects aka folders). This tool will return broad metadata from successful results and/or content matches. Use the Read tool next to read the results from those matches. Only ever refer to documents by name or with a document mention. Never state the id of the document in plaintext. User's are presented with the results of this tool as a UI element so there is no need to enumerate the information found from this tool.
 */
export interface UnifiedSearchInput {
  /**
   * Exhaustive search across all results matching the query. Defaults to true. Use false when the user only requires a limitied subset of results to answer the question
   */
  exhaustiveSearch: boolean;
  /**
   * Page offset. Default is 0. Use a higher offset to page through results intelligently. Set exhaustive_search to true to get all results.
   */
  pageOffset: number;
  /**
   * Search count per search type (i.e. applies separately to each of documents, emails, ai_conversations, chats, projects). Max is 100. Default is 10. Does not apply when exhaustive_search is set to true.
   */
  pageSize: number;
  /**
   * Aggregated search request, see individual fields for details
   */
  request: {
    /**
     * Search filters for various kinds of items. Set the entire filters property as `null` if you do not have specific filters for a given type, e.g. bcc for email filters.
     */
    filters: {
      /**
       * Channel filters. `null` to not filter channels searched over.
       */
      channel: {
        /**
         * Channel IDs to search within. Examples: ['general']. Empty to search all accessible channels.
         */
        channel_ids: string[];
        /**
         * Channel user mentions to search for. Examples: ['@username']. Empty if not filtering by mentions.
         */
        mentions: string[];
        /**
         * Channel organization ID to search within. Empty to ignore organization filtering.
         */
        org_id: number | null;
        /**
         * Sender IDs to search within. Examples: ['user1']. Empty to search all accessible senders.
         */
        sender_ids: string[];
        /**
         * Channel thread IDs to search within. Examples: ['thread123']. Empty to search all threads.
         */
        thread_ids: string[];
      } | null;
      /**
       * Chat filters. `null` to not filter chats searched over.
       */
      chat: {
        /**
         * Chat ids to search over. Examples: ['chat1'], ['chat1', 'chat2']. When provided, chat search will only match results on these chats. Empty to search all accessible chats.
         */
        chat_ids: string[];
        /**
         * Filter by chat owner. Examples: ['macro|user1@user.com'], ['macro|user1@user.com', 'macro|user2@user.com']. Empty to search all owners.
         */
        owners: string[];
        /**
         * A list of project ids to search within. Examples: ['project1']. Empty to ignore project filtering.
         */
        project_ids: string[];
        /**
         * Chat message roles to search. Examples: ['user'], ['assistant']. Empty to search all roles.
         */
        role: string[];
      } | null;
      /**
       * Document filters. `null` to not filter documents searched over.
       */
      document: {
        /**
         * Document ids to search over. Examples: ['doc1'], ['doc1', 'doc2']. Empty to search all accessible documents.
         */
        document_ids: string[];
        /**
         * Document file types to search. Examples: ['pdf'], ['md', 'txt']. Empty to search all file types.
         */
        file_types: string[];
        /**
         * Filter by document owner. Examples: ['macro|user1@user.com'], ['macro|user1@user.com', 'macro|user2@user.com']. Empty to search all owners.
         */
        owners: string[];
        /**
         * A list of project ids to search within. Examples: ['project1'].
         * filtering. Empty to ignore project filtering.
         */
        project_ids: string[];
      } | null;
      /**
       * Email filters. `null` to not filter emails searched over.
       */
      email: {
        /**
         * Email BCC addresses to filter by. Examples: ['user@example.com']. Empty if not filtering by BCC.
         */
        bcc: string[];
        /**
         * Email CC addresses to filter by. Examples: ['user@example.com']. Empty if not filtering by CC.
         */
        cc: string[];
        /**
         * Email Recipient addresses to filter by. Examples: ['user@example.com']. Empty if not filtering by Recipient.
         */
        recipients: string[];
        /**
         * Email sender addresses to filter by. Examples: ['user@example.com']. Empty to search all senders.
         */
        senders: string[];
      } | null;
      /**
       * Project filters. `null` to not filter projects searched over.
       */
      project: {
        /**
         * Filter by project owner. Examples: ['macro|user1@user.com'], ['macro|user1@user.com', 'macro|user2@user.com']. Empty to search all owners.
         */
        owners: string[];
        /**
         * Project IDs to search within. Examples: ['project1']. Empty to search all accessible projects.
         */
        project_ids: string[];
      } | null;
    } | null;
    /**
     * Include specific entity types from search. If empty, all entity types will be searched over. If you are unsure which types to search, use an empty array to search all.
     */
    include: ('documents' | 'chats' | 'emails' | 'channels' | 'projects')[];
    /**
     * How to match the search terms. 'exact' for precise case-sensitive phrase matches, 'partial' for prefix/partial matches. REQUIRED field.
     */
    match_type: 'exact' | 'partial' | 'regexp';
    /**
     * Fields to search on (Name, Content, NameContent). Defaults to Content
     */
    search_on: 'name' | 'content' | 'name_content';
    /**
     * Multiple distinct search terms as separate strings. Use this for keyword-based searches where you want to find content containing any of these terms. Each term must be at least 3 characters (shorter terms are automatically filtered out). Examples: ['machine', 'learning', 'algorithms'], ['project', 'status', 'update']. `null` this field if searching without text terms to search all. This field matches query string against both name and content.
     */
    terms: string[] | null;
  };
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface UnifiedSearchOutput {
  /**
   * The search results
   */
  response: {
    /**
     * The search results (truncated to `results_returned` limit if applicable)
     */
    results: (
      | {
          /**
           * The opensearch matches on the document
           */
          content?: string[] | null;
          /**
           * The document id
           */
          document_id: string;
          /**
           * The document name
           */
          document_name: string;
          /**
           * The file type
           */
          file_type: string;
          /**
           * The node id
           */
          node_id: string;
          /**
           * The owner id
           */
          owner_id: string;
          /**
           * The raw content of the document
           */
          raw_content?: string | null;
          type: 'document';
          /**
           * The time the document was last updated
           */
          updated_at: string;
        }
      | {
          /**
           * The chat id
           */
          chat_id: string;
          /**
           * The chat message id
           */
          chat_message_id: string;
          /**
           * The opensearch matches on the chat
           */
          content?: string[] | null;
          /**
           * The role
           */
          role: string;
          /**
           * The title
           */
          title: string;
          type: 'chat';
          /**
           * The time the chat was last updated
           */
          updated_at: string;
          /**
           * The user id
           */
          user_id: string;
        }
      | {
          /**
           * The bcc
           */
          bcc: string[];
          /**
           * The cc
           */
          cc: string[];
          /**
           * The opensearch matches on the email
           */
          content?: string[] | null;
          /**
           * The labels
           */
          labels: string[];
          /**
           * The link id
           */
          link_id: string;
          /**
           * The message id
           */
          message_id: string;
          /**
           * The recipients
           */
          recipients: string[];
          /**
           * The sender
           */
          sender: string;
          /**
           * The time the email was sent
           */
          sent_at?: string | null;
          /**
           * The subject
           */
          subject?: string | null;
          /**
           * The thread id
           */
          thread_id: string;
          type: 'email';
          /**
           * The time the email was last updated
           */
          updated_at: string;
          /**
           * The user id
           */
          user_id: string;
        }
      | {
          /**
           * The channel id
           */
          channel_id: string;
          /**
           * The channel name
           */
          channel_name?: string | null;
          /**
           * The channel type
           */
          channel_type: string;
          /**
           * The opensearch matches on the channel message
           */
          content?: string[] | null;
          /**
           * The time the channel message was created
           */
          created_at: string;
          /**
           * The mentions
           */
          mentions: string[];
          /**
           * The message id
           */
          message_id: string;
          /**
           * The org id
           */
          org_id?: number | null;
          /**
           * The sender id
           */
          sender_id: string;
          /**
           * The thread id
           */
          thread_id?: string | null;
          type: 'channel';
          /**
           * The time the channel message was last updated
           */
          updated_at: string;
        }
      | {
          /**
           * The opensearch matches on the project
           */
          content?: string[] | null;
          /**
           * The time the project was created
           */
          created_at: string;
          /**
           * The project id
           */
          project_id: string;
          /**
           * The project name
           */
          project_name: string;
          type: 'project';
          /**
           * The time the project was last updated
           */
          updated_at: string;
          /**
           * The id of the user who created the project
           */
          user_id: string;
        }
    )[];
    /**
     * the number of results returned
     */
    resultsReturned: number;
    /**
     * total number of results from search
     */
    totalResults: number;
  };
  /**
   * The JSON schema for the response so the LLM can understand it
   */
  responseSchema: {
    [k: string]: unknown;
  };
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Trigger an intelligent internet search tool with a search query. Phrase the query as a natural language question. The search tool only has the information passed into the query string to include any relevant context from the conversation. Use this tool when the user specifically requests a web search, asks for resources, asks for links, asks you to read documentationWhen referencing links returned by search remember to use github markdown notation to format them like this [description](https://example.com)Our CEO describes when to use web search like this: I think some important criteria for choosing to search the web are",
 *     if the user is asking for time-sensitive information (sports scores, news, current happenings, etc) that would have changed since the knowledge cutoff date
 *         Specific questions that reference external sources, eg contain a hyperlink in the user message or explicitly say “use webmd” or “check arxiv”
 *         do not use web search for things that are likely to find SEO slop content; this will make it worse than if it didn’t do it
 *         the LLM is be allowed to guess an answer and then use the web search tool to check AFTER providing the answer, if it feels it’s necessary. E.g. user asks “when was Caesar stabbed” -> llm gives answer -> if needed use web to double check"
 *     do not use this tool many times in a single response, you think the user may need more information ask them before calling web search again. You should always sharethe results of your search with the user even if you are not sure if they are useful
 */
export interface WebSearchInput {
  /**
   * The search string to search for. Should be long / descriptive
   */
  query: string;
}


/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface WebSearchOutput {
  content: string;
  results: {
    name: string;
    url: string;
  }[];
}

