//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.3
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord, BebopJson, BebopTypeGuard, Guid, GuidMap } from "bebop";

export const BEBOP_SCHEMA = new Uint8Array ([
3, 16, 0, 0, 0, 80, 101, 101, 114, 85, 112, 100, 97, 116,
101, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1, 117, 112, 100, 97, 116,
101, 0, 242, 255, 255, 255, 0, 254, 255, 255, 255, 0, 80,
101, 101, 114, 65, 119, 97, 114, 101, 110, 101, 115, 115,
0, 1, 0, 0, 4, 0, 0, 0, 0, 1, 97, 119, 97, 114, 101, 110,
101, 115, 115, 0, 242, 255, 255, 255, 0, 254, 255, 255,
255, 0, 80, 101, 101, 114, 82, 101, 113, 117, 101, 115,
116, 83, 105, 110, 99, 101, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1,
102, 114, 111, 110, 116, 105, 101, 114, 115, 0, 242, 255,
255, 255, 0, 254, 255, 255, 255, 0, 80, 101, 101, 114, 82,
101, 113, 117, 101, 115, 116, 83, 110, 97, 112, 115, 104,
111, 116, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 80, 101, 101, 114,
82, 101, 103, 105, 115, 116, 101, 114, 73, 100, 0, 1, 0,
0, 8, 0, 0, 0, 1, 1, 112, 101, 101, 114, 105, 100, 0, 249,
255, 255, 255, 0, 70, 114, 111, 109, 80, 101, 101, 114, 0,
3, 0, 5, 0, 0, 0, 5, 1, 0, 0, 0, 0, 2, 1, 0, 0, 0, 3, 2,
0, 0, 0, 4, 3, 0, 0, 0, 5, 4, 0, 0, 0, 82, 101, 109, 111,
116, 101, 73, 110, 105, 116, 105, 97, 108, 83, 121, 110,
99, 0, 1, 0, 0, 8, 0, 0, 0, 0, 2, 115, 110, 97, 112, 115,
104, 111, 116, 0, 242, 255, 255, 255, 0, 254, 255, 255,
255, 0, 97, 119, 97, 114, 101, 110, 101, 115, 115, 0, 242,
255, 255, 255, 0, 254, 255, 255, 255, 0, 82, 101, 109,
111, 116, 101, 85, 112, 100, 97, 116, 101, 0, 1, 0, 0, 4,
0, 0, 0, 0, 1, 117, 112, 100, 97, 116, 101, 0, 242, 255,
255, 255, 0, 254, 255, 255, 255, 0, 82, 101, 109, 111,
116, 101, 65, 119, 97, 114, 101, 110, 101, 115, 115, 0, 1,
0, 0, 4, 0, 0, 0, 0, 1, 97, 119, 97, 114, 101, 110, 101,
115, 115, 0, 242, 255, 255, 255, 0, 254, 255, 255, 255, 0,
82, 101, 109, 111, 116, 101, 83, 110, 97, 112, 115, 104,
111, 116, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1, 115, 110, 97, 112,
115, 104, 111, 116, 0, 242, 255, 255, 255, 0, 254, 255,
255, 255, 0, 82, 101, 109, 111, 116, 101, 85, 112, 100,
97, 116, 101, 65, 99, 107, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1,
117, 112, 100, 97, 116, 101, 0, 242, 255, 255, 255, 0,
254, 255, 255, 255, 0, 82, 101, 109, 111, 116, 101, 85,
112, 100, 97, 116, 101, 83, 105, 110, 99, 101, 0, 1, 0, 0,
8, 0, 0, 0, 0, 2, 117, 112, 100, 97, 116, 101, 0, 242,
255, 255, 255, 0, 254, 255, 255, 255, 0, 102, 114, 111,
110, 116, 105, 101, 114, 115, 0, 242, 255, 255, 255, 0,
254, 255, 255, 255, 0, 70, 114, 111, 109, 82, 101, 109,
111, 116, 101, 0, 3, 0, 9, 0, 0, 0, 6, 1, 6, 0, 0, 0, 2,
7, 0, 0, 0, 3, 8, 0, 0, 0, 4, 9, 0, 0, 0, 5, 10, 0, 0, 0,
6, 11, 0, 0, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110,
0, 1, 0, 0, 12, 0, 0, 0, 0, 2, 117, 112, 100, 97, 116,
101, 0, 242, 255, 255, 255, 0, 254, 255, 255, 255, 0, 116,
105, 109, 101, 115, 116, 97, 109, 112, 0, 243, 255, 255,
255, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 76,
111, 103, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1, 111, 112, 101,
114, 97, 116, 105, 111, 110, 115, 0, 242, 255, 255, 255,
0, 13, 0, 0, 0, 0, 73, 110, 105, 116, 105, 97, 108, 105,
122, 101, 70, 114, 111, 109, 83, 110, 97, 112, 115, 104,
111, 116, 82, 101, 113, 117, 101, 115, 116, 0, 1, 0, 0, 4,
0, 0, 0, 0, 1, 115, 110, 97, 112, 115, 104, 111, 116, 0,
242, 255, 255, 255, 0, 254, 255, 255, 255, 0, 0, 0, 0, 0
]);

export interface IPeerUpdate extends BebopRecord {

  readonly update: Uint8Array;
}

export class PeerUpdate implements IPeerUpdate {
  public readonly discriminator: number = 1 as 1;
  public static readonly discriminator: number = 1 as 1;
  public readonly update: Uint8Array;

  constructor(record: IPeerUpdate) {
    this.update = record.update;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return PeerUpdate.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IPeerUpdate): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    PeerUpdate.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link PeerUpdate}.
   */
  public static validateCompatibility(record: IPeerUpdate): void {
    BebopTypeGuard.ensureArray(record.update, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link PeerUpdate} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IPeerUpdate {
      return new PeerUpdate(record);
  }

  /**
   * Creates a new {@link PeerUpdate} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IPeerUpdate {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`PeerUpdate.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    PeerUpdate.validateCompatibility(parsed);
    return PeerUpdate.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return PeerUpdate.encode(this);
  }

  public static encode(record: IPeerUpdate): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    PeerUpdate.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IPeerUpdate, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.update);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IPeerUpdate {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return PeerUpdate.readFrom(view);
  }

  public static readFrom(view: BebopView): IPeerUpdate {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let message: IPeerUpdate = {
      update: field0,
    };
    return new PeerUpdate(message);
  }
}


export interface IPeerAwareness extends BebopRecord {

  readonly awareness: Uint8Array;
}

export class PeerAwareness implements IPeerAwareness {
  public readonly discriminator: number = 2 as 2;
  public static readonly discriminator: number = 2 as 2;
  public readonly awareness: Uint8Array;

  constructor(record: IPeerAwareness) {
    this.awareness = record.awareness;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return PeerAwareness.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IPeerAwareness): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    PeerAwareness.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link PeerAwareness}.
   */
  public static validateCompatibility(record: IPeerAwareness): void {
    BebopTypeGuard.ensureArray(record.awareness, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link PeerAwareness} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IPeerAwareness {
      return new PeerAwareness(record);
  }

  /**
   * Creates a new {@link PeerAwareness} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IPeerAwareness {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`PeerAwareness.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    PeerAwareness.validateCompatibility(parsed);
    return PeerAwareness.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return PeerAwareness.encode(this);
  }

  public static encode(record: IPeerAwareness): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    PeerAwareness.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IPeerAwareness, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.awareness);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IPeerAwareness {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return PeerAwareness.readFrom(view);
  }

  public static readFrom(view: BebopView): IPeerAwareness {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let message: IPeerAwareness = {
      awareness: field0,
    };
    return new PeerAwareness(message);
  }
}


export interface IPeerRequestSince extends BebopRecord {

  readonly frontiers: Uint8Array;
}

export class PeerRequestSince implements IPeerRequestSince {
  public readonly discriminator: number = 3 as 3;
  public static readonly discriminator: number = 3 as 3;
  public readonly frontiers: Uint8Array;

  constructor(record: IPeerRequestSince) {
    this.frontiers = record.frontiers;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return PeerRequestSince.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IPeerRequestSince): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    PeerRequestSince.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link PeerRequestSince}.
   */
  public static validateCompatibility(record: IPeerRequestSince): void {
    BebopTypeGuard.ensureArray(record.frontiers, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link PeerRequestSince} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IPeerRequestSince {
      return new PeerRequestSince(record);
  }

  /**
   * Creates a new {@link PeerRequestSince} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IPeerRequestSince {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`PeerRequestSince.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    PeerRequestSince.validateCompatibility(parsed);
    return PeerRequestSince.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return PeerRequestSince.encode(this);
  }

  public static encode(record: IPeerRequestSince): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    PeerRequestSince.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IPeerRequestSince, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.frontiers);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IPeerRequestSince {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return PeerRequestSince.readFrom(view);
  }

  public static readFrom(view: BebopView): IPeerRequestSince {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let message: IPeerRequestSince = {
      frontiers: field0,
    };
    return new PeerRequestSince(message);
  }
}


export interface IPeerRequestSnapshot extends BebopRecord {
}

export class PeerRequestSnapshot implements IPeerRequestSnapshot {
  public readonly discriminator: number = 4 as 4;
  public static readonly discriminator: number = 4 as 4;

  constructor(record: IPeerRequestSnapshot) {
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return PeerRequestSnapshot.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IPeerRequestSnapshot): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    PeerRequestSnapshot.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link PeerRequestSnapshot}.
   */
  public static validateCompatibility(record: IPeerRequestSnapshot): void {

  }

  /**
   * Unsafely creates an instance of {@link PeerRequestSnapshot} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IPeerRequestSnapshot {
      return new PeerRequestSnapshot(record);
  }

  /**
   * Creates a new {@link PeerRequestSnapshot} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IPeerRequestSnapshot {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`PeerRequestSnapshot.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    PeerRequestSnapshot.validateCompatibility(parsed);
    return PeerRequestSnapshot.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return PeerRequestSnapshot.encode(this);
  }

  public static encode(record: IPeerRequestSnapshot): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    PeerRequestSnapshot.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IPeerRequestSnapshot, view: BebopView): number {
    const before = view.length;

    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IPeerRequestSnapshot {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return PeerRequestSnapshot.readFrom(view);
  }

  public static readFrom(view: BebopView): IPeerRequestSnapshot {
    let message: IPeerRequestSnapshot = {
    };
    return new PeerRequestSnapshot(message);
  }
}


export interface IPeerRegisterId extends BebopRecord {

  readonly peerid: bigint;
}

export class PeerRegisterId implements IPeerRegisterId {
  public readonly discriminator: number = 5 as 5;
  public static readonly discriminator: number = 5 as 5;
  public readonly peerid: bigint;

  constructor(record: IPeerRegisterId) {
    this.peerid = record.peerid;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return PeerRegisterId.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IPeerRegisterId): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    PeerRegisterId.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link PeerRegisterId}.
   */
  public static validateCompatibility(record: IPeerRegisterId): void {
    BebopTypeGuard.ensureUint64(record.peerid)
  }

  /**
   * Unsafely creates an instance of {@link PeerRegisterId} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IPeerRegisterId {
      return new PeerRegisterId(record);
  }

  /**
   * Creates a new {@link PeerRegisterId} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IPeerRegisterId {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`PeerRegisterId.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    PeerRegisterId.validateCompatibility(parsed);
    return PeerRegisterId.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return PeerRegisterId.encode(this);
  }

  public static encode(record: IPeerRegisterId): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    PeerRegisterId.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IPeerRegisterId, view: BebopView): number {
    const before = view.length;
    view.writeUint64(record.peerid);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IPeerRegisterId {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return PeerRegisterId.readFrom(view);
  }

  public static readFrom(view: BebopView): IPeerRegisterId {
    let field0: bigint;
    field0 = view.readUint64();
    let message: IPeerRegisterId = {
      peerid: field0,
    };
    return new PeerRegisterId(message);
  }
}


export type IFromPeerType
  = { discriminator: 1, value: IPeerUpdate }
  | { discriminator: 2, value: IPeerAwareness }
  | { discriminator: 3, value: IPeerRequestSince }
  | { discriminator: 4, value: IPeerRequestSnapshot }
  | { discriminator: 5, value: IPeerRegisterId };

export interface IFromPeer extends BebopRecord {
  readonly data: IFromPeerType;
}
export class FromPeer implements IFromPeer {

  public readonly data: IFromPeerType;

  private constructor(data: IFromPeerType) {
    this.data = data;
  }

  public get discriminator() {
    return this.data.discriminator;
  }

  public get value() {
    return this.data.value;
  }

  public static fromPeerUpdate(value: IPeerUpdate) {
    return new FromPeer({ discriminator: 1, value: new PeerUpdate(value)});
  }

  public isPeerUpdate(): this is { value: PeerUpdate } & { data: Extract<IFromPeerType, { discriminator: 1 }> } {
    return this.data.value instanceof PeerUpdate;
  }

  public static fromPeerAwareness(value: IPeerAwareness) {
    return new FromPeer({ discriminator: 2, value: new PeerAwareness(value)});
  }

  public isPeerAwareness(): this is { value: PeerAwareness } & { data: Extract<IFromPeerType, { discriminator: 2 }> } {
    return this.data.value instanceof PeerAwareness;
  }

  public static fromPeerRequestSince(value: IPeerRequestSince) {
    return new FromPeer({ discriminator: 3, value: new PeerRequestSince(value)});
  }

  public isPeerRequestSince(): this is { value: PeerRequestSince } & { data: Extract<IFromPeerType, { discriminator: 3 }> } {
    return this.data.value instanceof PeerRequestSince;
  }

  public static fromPeerRequestSnapshot(value: IPeerRequestSnapshot) {
    return new FromPeer({ discriminator: 4, value: new PeerRequestSnapshot(value)});
  }

  public isPeerRequestSnapshot(): this is { value: PeerRequestSnapshot } & { data: Extract<IFromPeerType, { discriminator: 4 }> } {
    return this.data.value instanceof PeerRequestSnapshot;
  }

  public static fromPeerRegisterId(value: IPeerRegisterId) {
    return new FromPeer({ discriminator: 5, value: new PeerRegisterId(value)});
  }

  public isPeerRegisterId(): this is { value: PeerRegisterId } & { data: Extract<IFromPeerType, { discriminator: 5 }> } {
    return this.data.value instanceof PeerRegisterId;
  }


  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return FromPeer.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IFromPeer): string {
    delete (record.data.value as any).discriminator;
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    FromPeer.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link FromPeer}.
   */
  public static validateCompatibility(record: IFromPeer): void {
    const discriminator = record.data.discriminator;
    BebopTypeGuard.ensureUint8(discriminator);
    switch (discriminator) {
      case 1: {
        PeerUpdate.validateCompatibility(record.data.value);
        break;
      }
      case 2: {
        PeerAwareness.validateCompatibility(record.data.value);
        break;
      }
      case 3: {
        PeerRequestSince.validateCompatibility(record.data.value);
        break;
      }
      case 4: {
        PeerRequestSnapshot.validateCompatibility(record.data.value);
        break;
      }
      case 5: {
        PeerRegisterId.validateCompatibility(record.data.value);
        break;
      }
      default: {
        throw new Error(`Unknown discriminator for FromPeer: ${discriminator}`);
      }
    }
  }

  /**
   * Unsafely creates an instance of {@link FromPeer} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): FromPeer {
      const discriminator = record.data.discriminator;
      switch (discriminator) {
        case 1: {
          return new FromPeer({ discriminator: 1, value: PeerUpdate.unsafeCast(record.value) });
        }
        case 2: {
          return new FromPeer({ discriminator: 2, value: PeerAwareness.unsafeCast(record.value) });
        }
        case 3: {
          return new FromPeer({ discriminator: 3, value: PeerRequestSince.unsafeCast(record.value) });
        }
        case 4: {
          return new FromPeer({ discriminator: 4, value: PeerRequestSnapshot.unsafeCast(record.value) });
        }
        case 5: {
          return new FromPeer({ discriminator: 5, value: PeerRegisterId.unsafeCast(record.value) });
        }
      }
      throw new BebopRuntimeError(`Failed to unsafely cast union from discriminator: ${discriminator}`);
  }

  /**
   * Creates a new {@link FromPeer} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): FromPeer {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`FromPeer.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    FromPeer.validateCompatibility(parsed);
    return FromPeer.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return FromPeer.encode(this);
  }

  public static encode(record: IFromPeer): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    FromPeer.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IFromPeer, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length + 1;
    view.writeByte(record.data.discriminator);
    switch (record.data.discriminator) {
      case 1:
        PeerUpdate.encodeInto(record.data.value, view);
        break;
      case 2:
        PeerAwareness.encodeInto(record.data.value, view);
        break;
      case 3:
        PeerRequestSince.encodeInto(record.data.value, view);
        break;
      case 4:
        PeerRequestSnapshot.encodeInto(record.data.value, view);
        break;
      case 5:
        PeerRegisterId.encodeInto(record.data.value, view);
        break;
    }
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): FromPeer {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return FromPeer.readFrom(view);
  }

  public static readFrom(view: BebopView): FromPeer {
    const length = view.readMessageLength();
    const end = view.index + 1 + length;
    switch (view.readByte()) {
      case 1:
        return this.fromPeerUpdate(PeerUpdate.readFrom(view));
      case 2:
        return this.fromPeerAwareness(PeerAwareness.readFrom(view));
      case 3:
        return this.fromPeerRequestSince(PeerRequestSince.readFrom(view));
      case 4:
        return this.fromPeerRequestSnapshot(PeerRequestSnapshot.readFrom(view));
      case 5:
        return this.fromPeerRegisterId(PeerRegisterId.readFrom(view));
      default:
        view.index = end;
        throw new BebopRuntimeError("Unrecognized discriminator while decoding FromPeer");
    }
  }
}


export interface IRemoteInitialSync extends BebopRecord {

  readonly snapshot: Uint8Array;

  readonly awareness: Uint8Array;
}

export class RemoteInitialSync implements IRemoteInitialSync {
  public readonly discriminator: number = 1 as 1;
  public static readonly discriminator: number = 1 as 1;
  public readonly snapshot: Uint8Array;
  public readonly awareness: Uint8Array;

  constructor(record: IRemoteInitialSync) {
    this.snapshot = record.snapshot;
    this.awareness = record.awareness;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return RemoteInitialSync.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IRemoteInitialSync): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    RemoteInitialSync.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link RemoteInitialSync}.
   */
  public static validateCompatibility(record: IRemoteInitialSync): void {
    BebopTypeGuard.ensureArray(record.snapshot, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.awareness, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link RemoteInitialSync} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IRemoteInitialSync {
      return new RemoteInitialSync(record);
  }

  /**
   * Creates a new {@link RemoteInitialSync} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IRemoteInitialSync {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`RemoteInitialSync.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    RemoteInitialSync.validateCompatibility(parsed);
    return RemoteInitialSync.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return RemoteInitialSync.encode(this);
  }

  public static encode(record: IRemoteInitialSync): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    RemoteInitialSync.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IRemoteInitialSync, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.snapshot);
    view.writeBytes(record.awareness);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IRemoteInitialSync {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return RemoteInitialSync.readFrom(view);
  }

  public static readFrom(view: BebopView): IRemoteInitialSync {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: Uint8Array;
    field1 = view.readBytes();
    let message: IRemoteInitialSync = {
      snapshot: field0,
      awareness: field1,
    };
    return new RemoteInitialSync(message);
  }
}


export interface IRemoteUpdate extends BebopRecord {

  readonly update: Uint8Array;
}

export class RemoteUpdate implements IRemoteUpdate {
  public readonly discriminator: number = 2 as 2;
  public static readonly discriminator: number = 2 as 2;
  public readonly update: Uint8Array;

  constructor(record: IRemoteUpdate) {
    this.update = record.update;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return RemoteUpdate.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IRemoteUpdate): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    RemoteUpdate.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link RemoteUpdate}.
   */
  public static validateCompatibility(record: IRemoteUpdate): void {
    BebopTypeGuard.ensureArray(record.update, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link RemoteUpdate} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IRemoteUpdate {
      return new RemoteUpdate(record);
  }

  /**
   * Creates a new {@link RemoteUpdate} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IRemoteUpdate {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`RemoteUpdate.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    RemoteUpdate.validateCompatibility(parsed);
    return RemoteUpdate.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return RemoteUpdate.encode(this);
  }

  public static encode(record: IRemoteUpdate): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    RemoteUpdate.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IRemoteUpdate, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.update);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IRemoteUpdate {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return RemoteUpdate.readFrom(view);
  }

  public static readFrom(view: BebopView): IRemoteUpdate {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let message: IRemoteUpdate = {
      update: field0,
    };
    return new RemoteUpdate(message);
  }
}


export interface IRemoteAwareness extends BebopRecord {

  readonly awareness: Uint8Array;
}

export class RemoteAwareness implements IRemoteAwareness {
  public readonly discriminator: number = 3 as 3;
  public static readonly discriminator: number = 3 as 3;
  public readonly awareness: Uint8Array;

  constructor(record: IRemoteAwareness) {
    this.awareness = record.awareness;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return RemoteAwareness.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IRemoteAwareness): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    RemoteAwareness.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link RemoteAwareness}.
   */
  public static validateCompatibility(record: IRemoteAwareness): void {
    BebopTypeGuard.ensureArray(record.awareness, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link RemoteAwareness} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IRemoteAwareness {
      return new RemoteAwareness(record);
  }

  /**
   * Creates a new {@link RemoteAwareness} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IRemoteAwareness {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`RemoteAwareness.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    RemoteAwareness.validateCompatibility(parsed);
    return RemoteAwareness.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return RemoteAwareness.encode(this);
  }

  public static encode(record: IRemoteAwareness): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    RemoteAwareness.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IRemoteAwareness, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.awareness);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IRemoteAwareness {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return RemoteAwareness.readFrom(view);
  }

  public static readFrom(view: BebopView): IRemoteAwareness {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let message: IRemoteAwareness = {
      awareness: field0,
    };
    return new RemoteAwareness(message);
  }
}


export interface IRemoteSnapshot extends BebopRecord {

  readonly snapshot: Uint8Array;
}

export class RemoteSnapshot implements IRemoteSnapshot {
  public readonly discriminator: number = 4 as 4;
  public static readonly discriminator: number = 4 as 4;
  public readonly snapshot: Uint8Array;

  constructor(record: IRemoteSnapshot) {
    this.snapshot = record.snapshot;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return RemoteSnapshot.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IRemoteSnapshot): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    RemoteSnapshot.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link RemoteSnapshot}.
   */
  public static validateCompatibility(record: IRemoteSnapshot): void {
    BebopTypeGuard.ensureArray(record.snapshot, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link RemoteSnapshot} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IRemoteSnapshot {
      return new RemoteSnapshot(record);
  }

  /**
   * Creates a new {@link RemoteSnapshot} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IRemoteSnapshot {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`RemoteSnapshot.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    RemoteSnapshot.validateCompatibility(parsed);
    return RemoteSnapshot.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return RemoteSnapshot.encode(this);
  }

  public static encode(record: IRemoteSnapshot): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    RemoteSnapshot.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IRemoteSnapshot, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.snapshot);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IRemoteSnapshot {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return RemoteSnapshot.readFrom(view);
  }

  public static readFrom(view: BebopView): IRemoteSnapshot {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let message: IRemoteSnapshot = {
      snapshot: field0,
    };
    return new RemoteSnapshot(message);
  }
}


export interface IRemoteUpdateAck extends BebopRecord {

  readonly update: Uint8Array;
}

export class RemoteUpdateAck implements IRemoteUpdateAck {
  public readonly discriminator: number = 5 as 5;
  public static readonly discriminator: number = 5 as 5;
  public readonly update: Uint8Array;

  constructor(record: IRemoteUpdateAck) {
    this.update = record.update;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return RemoteUpdateAck.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IRemoteUpdateAck): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    RemoteUpdateAck.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link RemoteUpdateAck}.
   */
  public static validateCompatibility(record: IRemoteUpdateAck): void {
    BebopTypeGuard.ensureArray(record.update, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link RemoteUpdateAck} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IRemoteUpdateAck {
      return new RemoteUpdateAck(record);
  }

  /**
   * Creates a new {@link RemoteUpdateAck} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IRemoteUpdateAck {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`RemoteUpdateAck.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    RemoteUpdateAck.validateCompatibility(parsed);
    return RemoteUpdateAck.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return RemoteUpdateAck.encode(this);
  }

  public static encode(record: IRemoteUpdateAck): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    RemoteUpdateAck.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IRemoteUpdateAck, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.update);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IRemoteUpdateAck {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return RemoteUpdateAck.readFrom(view);
  }

  public static readFrom(view: BebopView): IRemoteUpdateAck {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let message: IRemoteUpdateAck = {
      update: field0,
    };
    return new RemoteUpdateAck(message);
  }
}


export interface IRemoteUpdateSince extends BebopRecord {

  readonly update: Uint8Array;

  readonly frontiers: Uint8Array;
}

export class RemoteUpdateSince implements IRemoteUpdateSince {
  public readonly discriminator: number = 6 as 6;
  public static readonly discriminator: number = 6 as 6;
  public readonly update: Uint8Array;
  public readonly frontiers: Uint8Array;

  constructor(record: IRemoteUpdateSince) {
    this.update = record.update;
    this.frontiers = record.frontiers;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return RemoteUpdateSince.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IRemoteUpdateSince): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    RemoteUpdateSince.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link RemoteUpdateSince}.
   */
  public static validateCompatibility(record: IRemoteUpdateSince): void {
    BebopTypeGuard.ensureArray(record.update, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.frontiers, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link RemoteUpdateSince} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IRemoteUpdateSince {
      return new RemoteUpdateSince(record);
  }

  /**
   * Creates a new {@link RemoteUpdateSince} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IRemoteUpdateSince {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`RemoteUpdateSince.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    RemoteUpdateSince.validateCompatibility(parsed);
    return RemoteUpdateSince.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return RemoteUpdateSince.encode(this);
  }

  public static encode(record: IRemoteUpdateSince): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    RemoteUpdateSince.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IRemoteUpdateSince, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.update);
    view.writeBytes(record.frontiers);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IRemoteUpdateSince {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return RemoteUpdateSince.readFrom(view);
  }

  public static readFrom(view: BebopView): IRemoteUpdateSince {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: Uint8Array;
    field1 = view.readBytes();
    let message: IRemoteUpdateSince = {
      update: field0,
      frontiers: field1,
    };
    return new RemoteUpdateSince(message);
  }
}


export type IFromRemoteType
  = { discriminator: 1, value: IRemoteInitialSync }
  | { discriminator: 2, value: IRemoteUpdate }
  | { discriminator: 3, value: IRemoteAwareness }
  | { discriminator: 4, value: IRemoteSnapshot }
  | { discriminator: 5, value: IRemoteUpdateAck }
  | { discriminator: 6, value: IRemoteUpdateSince };

export interface IFromRemote extends BebopRecord {
  readonly data: IFromRemoteType;
}
export class FromRemote implements IFromRemote {

  public readonly data: IFromRemoteType;

  private constructor(data: IFromRemoteType) {
    this.data = data;
  }

  public get discriminator() {
    return this.data.discriminator;
  }

  public get value() {
    return this.data.value;
  }

  public static fromRemoteInitialSync(value: IRemoteInitialSync) {
    return new FromRemote({ discriminator: 1, value: new RemoteInitialSync(value)});
  }

  public isRemoteInitialSync(): this is { value: RemoteInitialSync } & { data: Extract<IFromRemoteType, { discriminator: 1 }> } {
    return this.data.value instanceof RemoteInitialSync;
  }

  public static fromRemoteUpdate(value: IRemoteUpdate) {
    return new FromRemote({ discriminator: 2, value: new RemoteUpdate(value)});
  }

  public isRemoteUpdate(): this is { value: RemoteUpdate } & { data: Extract<IFromRemoteType, { discriminator: 2 }> } {
    return this.data.value instanceof RemoteUpdate;
  }

  public static fromRemoteAwareness(value: IRemoteAwareness) {
    return new FromRemote({ discriminator: 3, value: new RemoteAwareness(value)});
  }

  public isRemoteAwareness(): this is { value: RemoteAwareness } & { data: Extract<IFromRemoteType, { discriminator: 3 }> } {
    return this.data.value instanceof RemoteAwareness;
  }

  public static fromRemoteSnapshot(value: IRemoteSnapshot) {
    return new FromRemote({ discriminator: 4, value: new RemoteSnapshot(value)});
  }

  public isRemoteSnapshot(): this is { value: RemoteSnapshot } & { data: Extract<IFromRemoteType, { discriminator: 4 }> } {
    return this.data.value instanceof RemoteSnapshot;
  }

  public static fromRemoteUpdateAck(value: IRemoteUpdateAck) {
    return new FromRemote({ discriminator: 5, value: new RemoteUpdateAck(value)});
  }

  public isRemoteUpdateAck(): this is { value: RemoteUpdateAck } & { data: Extract<IFromRemoteType, { discriminator: 5 }> } {
    return this.data.value instanceof RemoteUpdateAck;
  }

  public static fromRemoteUpdateSince(value: IRemoteUpdateSince) {
    return new FromRemote({ discriminator: 6, value: new RemoteUpdateSince(value)});
  }

  public isRemoteUpdateSince(): this is { value: RemoteUpdateSince } & { data: Extract<IFromRemoteType, { discriminator: 6 }> } {
    return this.data.value instanceof RemoteUpdateSince;
  }


  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return FromRemote.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IFromRemote): string {
    delete (record.data.value as any).discriminator;
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    FromRemote.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link FromRemote}.
   */
  public static validateCompatibility(record: IFromRemote): void {
    const discriminator = record.data.discriminator;
    BebopTypeGuard.ensureUint8(discriminator);
    switch (discriminator) {
      case 1: {
        RemoteInitialSync.validateCompatibility(record.data.value);
        break;
      }
      case 2: {
        RemoteUpdate.validateCompatibility(record.data.value);
        break;
      }
      case 3: {
        RemoteAwareness.validateCompatibility(record.data.value);
        break;
      }
      case 4: {
        RemoteSnapshot.validateCompatibility(record.data.value);
        break;
      }
      case 5: {
        RemoteUpdateAck.validateCompatibility(record.data.value);
        break;
      }
      case 6: {
        RemoteUpdateSince.validateCompatibility(record.data.value);
        break;
      }
      default: {
        throw new Error(`Unknown discriminator for FromRemote: ${discriminator}`);
      }
    }
  }

  /**
   * Unsafely creates an instance of {@link FromRemote} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): FromRemote {
      const discriminator = record.data.discriminator;
      switch (discriminator) {
        case 1: {
          return new FromRemote({ discriminator: 1, value: RemoteInitialSync.unsafeCast(record.value) });
        }
        case 2: {
          return new FromRemote({ discriminator: 2, value: RemoteUpdate.unsafeCast(record.value) });
        }
        case 3: {
          return new FromRemote({ discriminator: 3, value: RemoteAwareness.unsafeCast(record.value) });
        }
        case 4: {
          return new FromRemote({ discriminator: 4, value: RemoteSnapshot.unsafeCast(record.value) });
        }
        case 5: {
          return new FromRemote({ discriminator: 5, value: RemoteUpdateAck.unsafeCast(record.value) });
        }
        case 6: {
          return new FromRemote({ discriminator: 6, value: RemoteUpdateSince.unsafeCast(record.value) });
        }
      }
      throw new BebopRuntimeError(`Failed to unsafely cast union from discriminator: ${discriminator}`);
  }

  /**
   * Creates a new {@link FromRemote} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): FromRemote {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`FromRemote.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    FromRemote.validateCompatibility(parsed);
    return FromRemote.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return FromRemote.encode(this);
  }

  public static encode(record: IFromRemote): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    FromRemote.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IFromRemote, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length + 1;
    view.writeByte(record.data.discriminator);
    switch (record.data.discriminator) {
      case 1:
        RemoteInitialSync.encodeInto(record.data.value, view);
        break;
      case 2:
        RemoteUpdate.encodeInto(record.data.value, view);
        break;
      case 3:
        RemoteAwareness.encodeInto(record.data.value, view);
        break;
      case 4:
        RemoteSnapshot.encodeInto(record.data.value, view);
        break;
      case 5:
        RemoteUpdateAck.encodeInto(record.data.value, view);
        break;
      case 6:
        RemoteUpdateSince.encodeInto(record.data.value, view);
        break;
    }
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): FromRemote {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return FromRemote.readFrom(view);
  }

  public static readFrom(view: BebopView): FromRemote {
    const length = view.readMessageLength();
    const end = view.index + 1 + length;
    switch (view.readByte()) {
      case 1:
        return this.fromRemoteInitialSync(RemoteInitialSync.readFrom(view));
      case 2:
        return this.fromRemoteUpdate(RemoteUpdate.readFrom(view));
      case 3:
        return this.fromRemoteAwareness(RemoteAwareness.readFrom(view));
      case 4:
        return this.fromRemoteSnapshot(RemoteSnapshot.readFrom(view));
      case 5:
        return this.fromRemoteUpdateAck(RemoteUpdateAck.readFrom(view));
      case 6:
        return this.fromRemoteUpdateSince(RemoteUpdateSince.readFrom(view));
      default:
        view.index = end;
        throw new BebopRuntimeError("Unrecognized discriminator while decoding FromRemote");
    }
  }
}


export interface IOperation extends BebopRecord {

  readonly update: Uint8Array;

  readonly timestamp: Date;
}

export class Operation implements IOperation {
  public readonly update: Uint8Array;
  public readonly timestamp: Date;

  constructor(record: IOperation) {
    this.update = record.update;
    this.timestamp = record.timestamp;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return Operation.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IOperation): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Operation.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Operation}.
   */
  public static validateCompatibility(record: IOperation): void {
    BebopTypeGuard.ensureArray(record.update, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureDate(record.timestamp)
  }

  /**
   * Unsafely creates an instance of {@link Operation} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IOperation {
      return new Operation(record);
  }

  /**
   * Creates a new {@link Operation} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IOperation {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Operation.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Operation.validateCompatibility(parsed);
    return Operation.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Operation.encode(this);
  }

  public static encode(record: IOperation): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Operation.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IOperation, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.update);
    view.writeDate(record.timestamp);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IOperation {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Operation.readFrom(view);
  }

  public static readFrom(view: BebopView): IOperation {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: Date;
    field1 = view.readDate();
    let message: IOperation = {
      update: field0,
      timestamp: field1,
    };
    return new Operation(message);
  }
}


export interface IOperationLog extends BebopRecord {

  readonly operations: Array<IOperation>;
}

export class OperationLog implements IOperationLog {
  public readonly operations: Array<IOperation>;

  constructor(record: IOperationLog) {
    this.operations = record.operations;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return OperationLog.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IOperationLog): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    OperationLog.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link OperationLog}.
   */
  public static validateCompatibility(record: IOperationLog): void {
    BebopTypeGuard.ensureArray(record.operations, Operation.validateCompatibility);
  }

  /**
   * Unsafely creates an instance of {@link OperationLog} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IOperationLog {
      return new OperationLog(record);
  }

  /**
   * Creates a new {@link OperationLog} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IOperationLog {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`OperationLog.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    OperationLog.validateCompatibility(parsed);
    return OperationLog.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return OperationLog.encode(this);
  }

  public static encode(record: IOperationLog): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    OperationLog.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IOperationLog, view: BebopView): number {
    const before = view.length;
    {
      const length0 = record.operations.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        Operation.encodeInto(record.operations[i0], view)
      }
    }
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IOperationLog {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return OperationLog.readFrom(view);
  }

  public static readFrom(view: BebopView): IOperationLog {
    let field0: Array<IOperation>;
    {
      let length0 = view.readUint32();
      field0 = new Array<IOperation>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IOperation;
        x0 = Operation.readFrom(view);
        field0[i0] = x0;
      }
    }
    let message: IOperationLog = {
      operations: field0,
    };
    return new OperationLog(message);
  }
}


export interface IInitializeFromSnapshotRequest extends BebopRecord {

  readonly snapshot: Uint8Array;
}

export class InitializeFromSnapshotRequest implements IInitializeFromSnapshotRequest {
  public readonly snapshot: Uint8Array;

  constructor(record: IInitializeFromSnapshotRequest) {
    this.snapshot = record.snapshot;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return InitializeFromSnapshotRequest.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IInitializeFromSnapshotRequest): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    InitializeFromSnapshotRequest.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link InitializeFromSnapshotRequest}.
   */
  public static validateCompatibility(record: IInitializeFromSnapshotRequest): void {
    BebopTypeGuard.ensureArray(record.snapshot, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link InitializeFromSnapshotRequest} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IInitializeFromSnapshotRequest {
      return new InitializeFromSnapshotRequest(record);
  }

  /**
   * Creates a new {@link InitializeFromSnapshotRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IInitializeFromSnapshotRequest {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`InitializeFromSnapshotRequest.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    InitializeFromSnapshotRequest.validateCompatibility(parsed);
    return InitializeFromSnapshotRequest.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return InitializeFromSnapshotRequest.encode(this);
  }

  public static encode(record: IInitializeFromSnapshotRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    InitializeFromSnapshotRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IInitializeFromSnapshotRequest, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.snapshot);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IInitializeFromSnapshotRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return InitializeFromSnapshotRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IInitializeFromSnapshotRequest {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let message: IInitializeFromSnapshotRequest = {
      snapshot: field0,
    };
    return new InitializeFromSnapshotRequest(message);
  }
}

